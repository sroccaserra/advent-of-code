## Combinatoire

Pour simplement passer en revue les nombres entre 11111111111111 et
99999999999999, je dois passer en revue 22,876,792,454,961 valeurs, c'est 23000
milliards. En faisant une estimation débile à base de 14 boucles for
imbriquées, le programme va prendre plus de 40 heures, et ça c'est sans rien
faire. Il doit y avoir une meilleure solution.

On pourrait chercher le premier nombre valide et voir à quoi il ressemble,
peut-être que ça donne des idées sur quoi éliminer.

## Exploration de l'input

Dans l'input, tous les read vont vers w, et s'ensuivent 17 opérations. On a
bien 18x14 = 252 lignes dans l'input.

Est-ce une répétition de 17 instructions identiques ? Non, il y a quelques
lignes qui changent un peu à chaque fois, toujours au même endroit.

Possible de reverse engineerer le programme ?

Let's debug!

On lit et on met dans w

a, b, c = 1, 12, 7
1.  x = 0
2.  x = z       # 1 et 2 : on copie z dans x
3.  x = x%26    # donc on calcule le modulo de z0 par 26
4.  z = z / a   # noop, pas encore utilisé pour le moment.
5.  x += b      # on ajoute 12, on est à x = (z0%26) + 12
6.  x = x eq w  # x = 1 si l'input est égal à (z0%26) + 12
7.  x = not x   # x = 1 si l'input est différent de z0%26 + 12
8.  y = 0
9.  y = 25      # on ajoute 25 à y, en pratique on a mis 25 dans y
10. y = y * x   # on met y à zéro si w est différent de z0%26+12
11. y += 1      # on incrémente y (qui devient 1 ou 26)
12. z = z * y   # z = (w == z0%26 + 12) ? z * 26 : z)
13. y = 0
14. y = w
15. y = w + c
16. y = y * x   # y = (w == z0%26+12) ? 0 : w + 7
17. z = z + y   # result += (w == z0%26+12) ? 0 : w + 7

a, b, c = 1, 12, 8
1.  x = 0
2.  x = z
3.  x = x%26
4.  z = z / 1
5.  x += 12
6.  x = x eq w
7.  x = not x
8.  y = 0
9.  y = 25
10. y = y * x
11. y += 1
12. z = z * y
13. y = 0
14. y = w
15. y = w + 8   # 8 au lieu de 7
16. y = y * x   # y = (w == z0%26+12) ? 0 : w + 8
17. z = z + y   # result += (w == z0%26+12) ? 0 : w + 8

a, b, c = 1, 13, 2
1.  x = 0
2.  x = z
3.  x = x%26
4.  z = z / 1
5.  x += 13     # on ajoute 13, on est à x = (z0%26) + 13
6.  x = x eq w  # x = 1 si l'input est égal à (z0%26) + 13
7.  x = not x   # x = 1 si l'input est différent de z0%26 + 13
8.  y = 0
9.  y = 25      # on ajoute 25 à y, en pratique on a mis 25 dans y
10. y = y * x   # on met y à zéro si w est différent de z0%26+13
11. y += 1      # on incrémente y (qui devient 1 ou 26)
12. z = z * y   # z = (w == z0%26 + 13) ? z * 26 : z)
13. y = 0
14. y = w
15. y = w + 2   # 2 au lieu de 7
16. y = y * x   # y = (w == z0%26+13) ? 0 : w + 2
17. z = z + y   # result += (w == z0%26+13) ? 0 : w + 2

a, b, c = 1, 12, 7
a, b, c = 1, 12, 8
a, b, c = 1, 13, 2
a, b, c = 1, 12, 11
a, b, c = 26, -3, 6
a, b, c = 1, 10, 12
a, b, c = 1, 14, 14
a, b, c = 26, -16, 13
a, b, c = 1, 12, 15
a, b, c = 26, -8, 10
a, b, c = 26, -12, 6
a, b, c = 26, -7, 10
a, b, c = 26, -6, 8
a, b, c = 26, -11, 5

z0 = state[3]
x = z0%26 + b
test1 = inp == z0%26+b
z = z0//a
y = 26 if test1 else 1
z = z * (26 if test1 else 1)
z += 0 if test1 else inp + c
