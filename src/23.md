
Vu le peu de points, peut-on faire un graphe √† la main ?

lower bound : 10 + 7 + 50 + 40 + 10000 + 4000 + 500 + 500 = 15107
lower bound : 15107
15107 = bad => too low
15108 = bad => too low
15109 = ?
15110 = bad
15111 = good ‚≠ê
15112 = ?
15113 too high
15137
15533 too high

Bon, c'est cheat√©.

```
#############
#...........#
###B#B#C#D###
  #D#C#A#A#
  #########
```

```
(1 1) (2 1) (3 1) (4 1) (5 1) (6 1) (7 1) (8 1) (9 1) (10 1) (11 1)
            (3 2)       (5 2)       (7 2)       (9 2)
            (3 3)       (5 3)       (7 3)       (9 3)
```

On pourrait vouloir √©liminer les noeuds o√π on ne peut pas s'arr√™ter, mais alors
il faut mettre des poids, on gagne un peu en perfs (?), on perd un peu en
complexit√© (?). Probablement qu'on n'aura pas besoin de faire cette
optimisation.

Il y a 19 noeuds, dont 8 sont occup√©s.

```
(1 1): (2 1)
(2 1): (3 1)
(3 1): (2 1) (3 2) (4 1)
(4 1): (3 1) (5 1)
(5 1): (4 1) (5 2) (6 1)
(6 1): (5 1) (7 1)
(7 1): (6 1) (7 2) (8 1)
(8 1): (7 1) (9 1)
(9 1): (8 1) (9 2) (10 1)
(10 1): (9 1) (11 1)
(11 1): (10 1)

(3 2): (3 1) (3 3)
(5 2): (5 1) (5 3)
(7 2): (7 1) (7 3)
(9 2): (9 1) (9 3)

(3 3): (3 2)
(5 3): (5 2)
(7 3): (7 2)
(9 3): (9 2)
```

Toute position o√π des pi√®ces √©quivalentes sont en m√™me position conduit √† la
m√™me solution.

Il va falloir faire une recherche de tous les cas possibles, si A bouge en
premier et ici, ... Si on mute la grille originale, il va falloir faire plein
de copies.

L'√©tat du jeu c'est l'ensemble des positions des amphipodes. Peut-√™tre qu'on
n'a pas besoin de rendre identiques A1 et A2.

A chaque √©tape, on a n <= 8 amphipodes qui peuvent bouger dans m <= 11
positions. Borne haute de possibilit√©s pour une √©tape : 88.

Nomenclature : solution = arriver √† la position finale, r√©sultat = √©nergie pour
arriver √† la solution.

Peut-on trouver une solution quelconque facilement pour trouver une borne sup
du r√©sultat ?  Quand on a une solution, on a une valeurs au del√† de laquelle on
n'a pas besoin de continuer √† chercher.C'est pas tr√®s compliqu√© de trouver une
solution quelconque √† la main, on a notre borne sup du r√©sultat pour arr√™ter la
recherche : 15113 üí°. Ensuite, d√®s qu'on trouve une solution qui donne un
r√©sultat inf√©rieur, on peut mettre √† jour notre borne sup si on veut.  Toute
solution qui d√©place les D de plus de 15 pas est mauvaise.

On sait aussi calculer une borne inf du r√©sultat facilement en regardant les
distances initiales de chaque amphipode √† leur position finale : 15107.

Hypoth√®se 1 : quand un amphipode est arriv√© √† sa destination, il ne bouge plus.

On peut traquer les amphipodes arriv√©s √† destination et renvoyer un r√©sultat
d√®s que tous les amphipodes sont arriv√©s.

Nomenclature : branche = choix d'un amphipode √† d√©placer et sa destination.

√âbauche de plan, pour chaque √©tat :
- s'il n'y a pas de branche possible, c'est que les amphipodes sont arriv√©s,
  renvoyer 0 comme r√©sultat
- pour chaque branche possible, d√©terminer r√©cursivement le r√©sultat de la
  suite, le r√©sultat de la branche est le d√©placement de la branche plus ce
  r√©sultat, et choisir la branche qui minimise ce r√©sultat.

### Premi√®re √©tape

- ‚úÖ impl√©menter les r√®gles de d√©placement (voir hypoth√®se 3)
- ‚úÖ pouvoir lister toutes les branches √† partir d'un √©tat donn√©

On peut lister les d√©placements possibles, mais pour les colonnes destinations,
le d√©placement est possible, c'est l'arret qui est impossible.

Hypoth√®se 2 (remplac√©e par l'hypoth√®se 3) : on pourrait dire qu'il n'y a qu'un
seul amphipode qui peut √™tre sur une ce ces colonnes √† la fois, √ßa devrait ne
donner que des √©tats coh√©rents.

Hypoth√®se 3 (remplace l'hypoth√®se 2) : si un amphipode est sur une case 'non
stoppable', alors tous les autres amphipodes n'ont aucun mouvement possible.

Question 1 : est-ce qu'un amphipode peut stationner en haut de sa colonne de
destination si le fond de celle-ci est occup√©e par un autre amphipode qui n'a
pas encore boug√© ?

### Deuxi√®me √©tape

- ‚≠ï recherche des r√©sultats

Plan impl√©ment√© :
- ‚úÖ s'il n'y a pas de branche possible, c'est que les amphipodes sont arriv√©s,
  renvoyer 0 comme r√©sultat
- ‚úÖ pour chaque branche possible, d√©terminer r√©cursivement le r√©sultat de la
  suite, le r√©sultat de la branche est le d√©placement de la branche plus ce
  r√©sultat, et choisir la branche qui minimise ce r√©sultat.

Mmm, j'ai mis une table de m√©moisation, mais je n'arrive pas √† ma condition
d'arr√™t, je d√©passe le max de r√©cursion possible en Python (1000 pour mon cas).
Dans un √©lan d'optimisme, j'ai boost√© ce max √† 2000 puis 1000 sans effet
observable.

Comment faire pour garantir d'arriver √† une solution et commencer √† d√©piler
avant d'atteindre le max de profondeur de stack ? ü§î

Faisons des essais sur des probl√®mes plus simples. Est-ce que j'ai bien z√©ro
comme co√ªt minimum pour un terrier o√π les amphipodes sont √† la bonne place ?
Oui. Cool.

Un essai o√π deux amphipodes sont invers√©s. Ah, la r√©cursion explose üí•, voyons
ce qui coince üîé ! Ah mais oui, il me faut sans doute aussi une liste d'√©tats
non encore trouv√©s mais d√©j√† en cours de visite ! Let's go!

üö£ Bon, maintenant j'√©vite de lancer deux recherches d'un m√™me √©tat, mais du
coup je me retrouve avec des branches sans r√©sultats. J'ai d√ª mal agencer ma
recherche.

Qu'est-ce que √ßa veut dire qu'une branche est sans r√©sultat ? Que je parcours
l'espace des solutions dans le mauvais ordre ? Quel est le bon ordre ?

Est-ce qu'on peut r√©soudre le pb √† l'envers ? Partir de la position d'arriv√©e
qui vaut z√©ro, et bouger jusqu'√† arriver √† la position de d√©part ? Il semble
que les deux probl√®mes sont √©quivalents, pas besoin d'inverser ?

Essai de deux algorithmes non r√©cursif, √† base de queue et de stack et de
revisites : pas les bons r√©sultats. Avec une stack, c'est tr√®s rapide, mais √ßa
donne un r√©sultat fantaisiste pour l'exemple (38867). Avec queue, pour
l'exemple : 12521... Ah si, c'est le bon r√©sultat pour l'exemple, un peu long
(17 s) mais √ßa passe.

Probl√®me : avec mon jeu de donn√©es, avec une queue √ßa tourne plusieurs minutes
sans rien donner üò¢. Pff, qu'est-ce qui se passe ? Qu'est-ce qu'on pourrait
m√©moiser ?

Essayons sans revisite. ‚ùå Sans revisite : le nombre n'est plus bon pour
l'exemple.

Exploration de la combinatoire : il y a 75582 fa√ßons de ranger 8 pi√®ces dans 19
espaces. C'est probablement un probl√®me un peu diff√©rent, car dans le cas du
puzzle il y a des pi√®ces interchangeables, et des positions non possibles, donc
c'est sans doute une borne haute.

Il y avait un probl√®me avec revisite les jours pr√©c√©dent, allons voir ce que
j'avais fait pour le jour 15.

Ok, j'ai test√© deux des algos que j'avais utilis√© pour le jour 15, un avec
queue et un avec heapq, les deux donnent la bonne r√©ponse pour l'exemple, mais
c'est toujours aussi long (19 s), et surtout √ßa ne se termine pas apr√®s
plusieurs minutes pour mon input üò¢ Il doit y avoir une mouche dans le potage.
