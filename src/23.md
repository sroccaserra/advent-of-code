
Vu le peu de points, peut-on faire un graphe √† la main ?

lower bound : 10 + 7 + 50 + 40 + 10000 + 4000 + 500 + 500 = 15107
lower bound : 15107
15107 = bad => too low
15108 = bad => too low
15109 = ?
15110 = bad
15111 = good ‚≠ê
15112 = ?
15113 too high
15137
15533 too high

Bon, c'est cheat√©.

```
#############
#...........#
###B#B#C#D###
  #D#C#A#A#
  #########
```

```
(1 1) (2 1) (3 1) (4 1) (5 1) (6 1) (7 1) (8 1) (9 1) (10 1) (11 1)
            (3 2)       (5 2)       (7 2)       (9 2)
            (3 3)       (5 3)       (7 3)       (9 3)
```

On pourrait vouloir √©liminer les noeuds o√π on ne peut pas s'arr√™ter, mais alors
il faut mettre des poids, on gagne un peu en perfs (?), on perd un peu en
complexit√© (?). Probablement qu'on n'aura pas besoin de faire cette
optimisation.

Il y a 19 noeuds, dont 8 sont occup√©s.

```
(1 1): (2 1)
(2 1): (3 1)
(3 1): (2 1) (3 2) (4 1)
(4 1): (3 1) (5 1)
(5 1): (4 1) (5 2) (6 1)
(6 1): (5 1) (7 1)
(7 1): (6 1) (7 2) (8 1)
(8 1): (7 1) (9 1)
(9 1): (8 1) (9 2) (10 1)
(10 1): (9 1) (11 1)
(11 1): (10 1)

(3 2): (3 1) (3 3)
(5 2): (5 1) (5 3)
(7 2): (7 1) (7 3)
(9 2): (9 1) (9 3)

(3 3): (3 2)
(5 3): (5 2)
(7 3): (7 2)
(9 3): (9 2)
```

Toute position o√π des pi√®ces √©quivalentes sont en m√™me position conduit √† la
m√™me solution.

Il va falloir faire une recherche de tous les cas possibles, si A bouge en
premier et ici, ... Si on mute la grille originale, il va falloir faire plein
de copies.

L'√©tat du jeu c'est l'ensemble des positions des amphipodes. Peut-√™tre qu'on
n'a pas besoin de rendre identiques A1 et A2.

A chaque √©tape, on a n <= 8 amphipodes qui peuvent bouger dans m <= 11
positions. Borne haute de possibilit√©s pour une √©tape : 88.

Nomenclature : solution = arriver √† la position finale, r√©sultat = √©nergie pour
arriver √† la solution.

Peut-on trouver une solution quelconque facilement pour trouver une borne sup
du r√©sultat ?  Quand on a une solution, on a une valeurs au del√† de laquelle on
n'a pas besoin de continuer √† chercher.C'est pas tr√®s compliqu√© de trouver une
solution quelconque √† la main, on a notre borne sup du r√©sultat pour arr√™ter la
recherche : 15113 üí°. Ensuite, d√®s qu'on trouve une solution qui donne un
r√©sultat inf√©rieur, on peut mettre √† jour notre borne sup si on veut.  Toute
solution qui d√©place les D de plus de 15 pas est mauvaise.

On sait aussi calculer une borne inf du r√©sultat facilement en regardant les
distances initiales de chaque amphipode √† leur position finale : 15107.

Hypoth√®se 1 : quand un amphipode est arriv√© √† sa destination, il ne bouge plus.

On peut traquer les amphipodes arriv√©s √† destination et renvoyer un r√©sultat
d√®s que tous les amphipodes sont arriv√©s.

Nomenclature : branche = choix d'un amphipode √† d√©placer et sa destination.

√âbauche de plan, pour chaque √©tat :
- s'il n'y a pas de branche possible, c'est que les amphipodes sont arriv√©s,
  renvoyer 0 comme r√©sultat
- pour chaque branche possible, d√©terminer r√©cursivement le r√©sultat de la
  suite, le r√©sultat de la branche est le d√©placement de la branche plus ce
  r√©sultat, et choisir la branche qui minimise ce r√©sultat.

### Premi√®re √©tape

- ‚úÖ impl√©menter les r√®gles de d√©placement (voir hypoth√®se 3)
- ‚úÖ pouvoir lister toutes les branches √† partir d'un √©tat donn√©

On peut lister les d√©placements possibles, mais pour les colonnes destinations,
le d√©placement est possible, c'est l'arret qui est impossible.

Hypoth√®se 2 (remplac√©e par l'hypoth√®se 3) : on pourrait dire qu'il n'y a qu'un
seul amphipode qui peut √™tre sur une ce ces colonnes √† la fois, √ßa devrait ne
donner que des √©tats coh√©rents.

Hypoth√®se 3 (remplace l'hypoth√®se 2) : si un amphipode est sur une case 'non
stoppable', alors tous les autres amphipodes n'ont aucun mouvement possible.

Question 1 : est-ce qu'un amphipode peut stationner en haut de sa colonne de
destination si le fond de celle-ci est occup√©e par un autre amphipode qui n'a
pas encore boug√© ?

### Deuxi√®me √©tape

- ‚≠ï recherche des r√©sultats

Plan impl√©ment√© :
- ‚úÖ s'il n'y a pas de branche possible, c'est que les amphipodes sont arriv√©s,
  renvoyer 0 comme r√©sultat
- ‚úÖ pour chaque branche possible, d√©terminer r√©cursivement le r√©sultat de la
  suite, le r√©sultat de la branche est le d√©placement de la branche plus ce
  r√©sultat, et choisir la branche qui minimise ce r√©sultat.

Mmm, j'ai mis une table de m√©moisation, mais je n'arrive pas √† ma condition
d'arr√™t, je d√©passe le max de r√©cursion possible en Python (1000 pour mon cas).
Dans un √©lan d'optimisme, j'ai boost√© ce max √† 2000 puis 1000 sans effet
observable.

Comment faire pour garantir d'arriver √† une solution et commencer √† d√©piler
avant d'atteindre le max de profondeur de stack ? ü§î

Faisons des essais sur des probl√®mes plus simples. Est-ce que j'ai bien z√©ro
comme co√ªt minimum pour un terrier o√π les amphipodes sont √† la bonne place ?
Oui. Cool.

Un essai o√π deux amphipodes sont invers√©s. Ah, la r√©cursion explose üí•, voyons
ce qui coince üîé ! Ah mais oui, il me faut sans doute aussi une liste d'√©tats
non encore trouv√©s mais d√©j√† en cours de visite ! Let's go!

üö£ Bon, maintenant j'√©vite de lancer deux recherches d'un m√™me √©tat, mais du
coup je me retrouve avec des branches sans r√©sultats. J'ai d√ª mal agencer ma
recherche.

Qu'est-ce que √ßa veut dire qu'une branche est sans r√©sultat ? Que je parcours
l'espace des solutions dans le mauvais ordre ? Quel est le bon ordre ?

Est-ce qu'on peut r√©soudre le pb √† l'envers ? Partir de la position d'arriv√©e
qui vaut z√©ro, et bouger jusqu'√† arriver √† la position de d√©part ? Il semble
que les deux probl√®mes sont √©quivalents, pas besoin d'inverser ?

Essai de deux algorithmes non r√©cursif, √† base de queue et de stack et de
revisites : pas les bons r√©sultats. Avec une stack, c'est tr√®s rapide, mais √ßa
donne un r√©sultat fantaisiste pour l'exemple (38867). Avec queue, pour
l'exemple : 12521... Ah si, c'est le bon r√©sultat pour l'exemple, un peu long
(17 s) mais √ßa passe.

Probl√®me : avec mon jeu de donn√©es, avec une queue √ßa tourne plusieurs minutes
sans rien donner üò¢. Pff, qu'est-ce qui se passe ? Qu'est-ce qu'on pourrait
m√©moiser ?

Essayons sans revisite. ‚ùå Sans revisite : le nombre n'est plus bon pour
l'exemple.

Exploration de la combinatoire : il y a 75582 fa√ßons de ranger 8 pi√®ces dans 19
espaces. C'est probablement un probl√®me un peu diff√©rent, car dans le cas du
puzzle il y a des pi√®ces interchangeables, et des positions non possibles, donc
c'est sans doute une borne haute.

Il y avait un probl√®me avec revisite les jours pr√©c√©dent, allons voir ce que
j'avais fait pour le jour 15.

Ok, j'ai test√© deux des algos que j'avais utilis√© pour le jour 15, un avec
queue et un avec heapq, les deux donnent la bonne r√©ponse pour l'exemple, mais
c'est toujours aussi long (19 s), et surtout √ßa ne se termine pas apr√®s
plusieurs minutes pour mon input üò¢ Il doit y avoir une mouche dans le potage.

Essai d'ajouter une valeur o√π on stope la recherche (facile √† obtenir en
faisant un essai random √† la main). L'exemple passe toujours en le m√™me temps,
pas l'input. √áa sent le bug, j'ai d√ª oublier un cas dans les r√®gles, il faudra
que je relise tout.

Tiens, je n'avais pas lu la derni√®re r√®gle üôÉ

> Once an amphipod stops moving in the hallway, it will stay in that spot until
> it can move into a room. (That is, once any amphipod starts moving, any other
> amphipods currently in the hallway are locked in place and will not move
> again until they can move fully into a room.)

Se pourrait-il que...

Ok, cette r√®gle est compliqu√©e √† impl√©menter √† posteriori avec tout le bazar
que j'ai mis en place. J'ai l'amphipode courrant qui peut se d√©placer, des
amphipodes lock√©s car ils se sont d√©j√† d√©plac√©s, mais je n'ai pas le mouvement
vers la colonne finale possible, du coup √ßa s'arr√™te trop t√¥t.

Tentative qui fait fonctionner un exemple simple (inversion simple de deux
valeurs), mais qui coince sur l'exemple et mon input. Flemme de repartir sur
une autre repr√©sentation pour pouvoir coder la r√®gle manquante correctement, et
pas d'id√©e pour aller plus loin avec ma repr√©sentation actuelle.

Au final, si j'examine mon input, la partie 1 est paper-for√ßable √† l'instinct
(done), surtout si on se donne un ordre de grandeur en regardant les mouvements
mins de chaque pi√®ce, et la partie 2, voyons-voir... Ok, en suivant le m√™me
principe, et en observant qu'une configuration finale pour les A est
obligatoire, √ßa devient un probl√®me de logique int√©ressant : il n'y a que deux
colonnes vidables en premier, et pour vider chacune on n'a pas trop de choix.
Apr√®s avoir d√©termin√© la colonne √† vider en premier, j'ai eu deux mouvements
plus compliqu√©s √† optimiser, mais c'est pass√© pour la partie 2.

----

Reboot!

Il y a un couloir en haut, et quatre colonnes. On ne peut bouger que d'une
colonne vers le couloir, ou du couloir dans sa colonne d√©finitive si celle-ci
ne contient pas de mauvais amphipode.

Quelle structure de donn√©e faciliterait l'√©num√©ration ou la validation des
mouvements possibles ?

```
#############
#.. . . . ..#
###.#.#.#.###
  #.#.#.#.#
  #########
```

Le couloir contient 7 destinations possibles.

```
#############
#.. . . . ..#
### # # # ###
```

Les colonnes contiennent deux (quatre) destinations possibles par colonne.

```
###.#.#.#.###
  #.#.#.#.#
  #########
```

Si on note k0..k6 les positions dans le couloir, et a0, a1, .. , d0, d1 les
cases des colonnes, avec a0 etc. repr√©sentant le sommet de la colonne, on peut
lister les arr√®tes entre couloir et colonnes comme √ßa :

- k0: [(a0, 3), (a1, 4), (b0, 5), (b1, 6), (c0, 7), (c1, 8), (d0, 9), (d1, 10)]
- k1: [(a0, 2), (a1, 3), (b0, 4), (b1, 5), (c0, 6), (c1, 7), (d0, 8), (d1, 9)]
...

On peut se contenter de noter la distance avec a0, b0, c0 et d0, et d√©duire la
distance avec a1, b1... en ajoutant 1.

On peut noter "a" la colonne des "A", etc.

```
:::::::::::::
:01 2 3 4 56:
:::a:b:c:d:::

    a  b  c  d

k0  3  5  7  9
k1  2  4  6  8
k2  2  2  4  6
k3  4  2  2  4
k4  6  4  2  2
k5  8  6  4  2
k6  9  7  5  3
```

- üí° on n'a pas besoin de les ranger dans les pi√®ces, il suffit de les amener √†
  l'entr√©e de leur pi√®ce, ensuite le rangement est constant, pareil pour les
  sortir, l'ordre suffit, le co√ªt sera identique. L'√©tat d'une pi√®ce c'est
  "est-ce qu'il en reste 4, 3, 2, 1 ou z√©ro dans la pi√®ce"

- Du coup on peut mod√©liser les chambres = 4 chiffres de z√©ro √† quatre, couloir
  = 4 chiffres de z√©ro √† quatre.

### Plan

Convention : je pr√©f√®re dire "bops" que "amphipode", donc √† partir de
maintenant je vais appeler "bops" les "amphipodes".

- Etape 1 : pour une position de d√©part donn√©e, savoir calculer le co√ªt de
  sortie et le co√ªt de rangement. C'est une bonne mise en jambe.
- Etape 2 : draw the fucking owl.

#### Etape 1.1 : co√ªt de sortie

Pour l'exemple :

```
  :B:C:B:D:
  :A:D:C:A:
```

On peut le faire par colonne.
- Pour la colonne a, le co√ªt de sortie est de Bx1 + Ax0, l'ordre de sortie de colonne est [B].
- Pour la colonne b, le co√ªt de sortie est de Cx1 + Dx2, l'ordre de sortie de colonne est [C, D].
- Pour la colonne c, le co√ªt de sortie est de Bx1 + Cx0, l'ordre de sortie de colonne est [B].
- Pour la colonne d, le co√ªt de sortie est de Dx1 + Ax2, l'ordre de sortie de colonne est [D, A].

Co√ªt total : 10+100+2000+10+1000+2 = 3122

On peut regarder aussi l'exemple en version partie 2 :

```
  :B:C:B:D:
  :D:C:B:A:
  :D:B:A:C:
  :A:D:C:A:
```

- a: 10x1 + 1000x2 + 1000x3 + 1x0, "BDD"
- b: 100x1 + 100x2 + 10x3 + 1000x4, "CCBD"
- c: 10x1 + 10x2 + 1x3 + 100x0, "BBA"
- d: 1000x1 + 1x2 + 100x3 + 1x4, "DACA"

Pour construire une colonne, on peut commencer en bas avec un index √† 4, et un
coefficient √† 0 tant que c'est la bonne lettre, qui devient 1 d√®s qu'une lettre
n'est pas bien positionn√©e, et qui ne change plus ensuite. L'index d√©cr√©mente
de 4 √† 1, et on multiplie par la valeur de la lettre. On peut push les lettres
√† bouger dans une pile, qu'on popera ensuite.

#### Etape 1.2 : co√ªt de rangement

Le co√ªt du rangement est le co√ªt de chaque bops x (1 + 2) ou x (1 + 2 + 3 + 4)
moins le co√ªt des bops d√©j√† rang√©s. Ce qui est variable c'est le co√ªt des bops
d√©j√† rang√©s, qu'on peut calculer en m√™me temps que le co√ªt de sortie.

#### Simplification du probl√®me

Donc on peut avoir une fonction co√ªt fixe calcul√©e au d√©part, et r√©soudre le
probl√®me de faire entrer les bops dans le couloir par leur porte d'entr√©e dans
l'ordre donn√© par l'input, et de les faire sortir par la bonne colonne.

Dans ce contexte, l'√©tat du jeu c'est les bops dans le couloir, et quatre piles
de bops √† faire rentrer.

Les bops qui peuvent bouger sont :
- les bops en haut de chaque pile,
- les bops dans le couloir.

Les mouvements qu'ils peuvent effectuer, c'est respectivement :
- rejoindre les cases du couloirs visitables depuis leur pi√®ce de d√©part,
- rejoindre leur pi√®ce d'arriv√©e d√®s qu'elle est visitable depuis leur position
  dans le couloir.

Pour s'assurer qu'un point est accessible, on pourrait pr√©calculer les listes
de points entre pi√®ces et positions du couloir √† partir d'une string comme √ßa
par exemple : "01a2b3c4d56". Pour chaque lettre, pour chaque chiffre, lister
les chiffres inclus entre la lettre et le chiffre. Ensuite, quand on veut
savoir si une position du couloir est accessible depuis une pi√®ce (ou
r√©ciproquement), on pourrait dire "est-ce qu'il n'y a aucun bops dans les
positions entre lettre et chiffre ?"
